//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"reflect"
	"strings"
)

const packageHdr = `
// Code generated by "go run generate_coercers.go"; DO NOT EDIT.
package venom
`

const pkgImports = `
import "fmt"

`

const coerceErr = `
// A CoerceErr is returned when incompatible types are attempted to be coerced
type CoerceErr struct{
	From interface{}
	To string
	Err error
}

func (e *CoerceErr) Error() string {
	return fmt.Sprintf("venom: can not coerce %T to %q", e.From, e.To)
}

`

const packageIntro = packageHdr + pkgImports + coerceErr

var (
	types = []reflect.Kind{
		reflect.String,
		reflect.Bool,
		reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32,
		reflect.Uint64,
		reflect.Float32, reflect.Float64,
		// "struct",
		// "slice",
	}

	kindToType = map[reflect.Kind]reflect.Type{
		reflect.String:  reflect.TypeOf(""),
		reflect.Bool:    reflect.TypeOf(true),
		reflect.Int:     reflect.TypeOf(int(0)),
		reflect.Int8:    reflect.TypeOf(int8(0)),
		reflect.Int16:   reflect.TypeOf(int16(0)),
		reflect.Int32:   reflect.TypeOf(int32(0)),
		reflect.Int64:   reflect.TypeOf(int64(0)),
		reflect.Uint:    reflect.TypeOf(uint(0)),
		reflect.Uint8:   reflect.TypeOf(uint8(0)),
		reflect.Uint16:  reflect.TypeOf(uint16(0)),
		reflect.Uint32:  reflect.TypeOf(uint32(0)),
		reflect.Uint64:  reflect.TypeOf(uint64(0)),
		reflect.Float32: reflect.TypeOf(float32(0.0)),
		reflect.Float64: reflect.TypeOf(float64(0.0)),
	}
)

func zeroValue(k reflect.Kind) interface{} {
	return reflect.Zero(kindToType[k]).Interface()
}

func kindTitle(k reflect.Kind) string {
	return strings.Replace(
		k.String(),
		string(k.String()[0]),
		strings.ToUpper(string(k.String()[0])),
		-1,
	)
}

func writeCaster(to reflect.Kind) string {
	zeroValFmt := "%v"
	if to == reflect.String {
		zeroValFmt = "%q"
	}
	return fmt.Sprintf(`if value, ok := val.(%s); !ok {
		return `+zeroValFmt+`, &CoerceErr{From: val, To: %q}
	} else {
		return value, nil
	}
`, to, zeroValue(to), to)
}

func writeSliceCaster(to reflect.Kind) string {
	return fmt.Sprintf(`switch val.(type) {
	case []%s:
		return val.([]%s), nil
	case nil:
		return nil, nil
	case []interface{}:
		var container []%s
		for _, item := range val.([]interface{}) {
			coerced, err := coerce%s(item)
			if err != nil {
				return nil, &CoerceErr{val, "[]%s", err}
			}
			container = append(container, coerced)
		}
		return container, nil
	default:
		return nil, &CoerceErr{From: val, To: "[]%s"}
	}
`, to, to, to, kindTitle(to), to, to)
}

func writeIntSliceCaster() string {
	return `func coerceIntSlice(val interface{}) ([]int, error) {
	switch val.(type) {
	case []int:
		return val.([]int), nil
	case nil:
		return nil, nil
	case []interface{}:
		var container []int
		for _, item := range val.([]interface{}) {
			var coerced int
			var err error
			switch item.(type) {
			// this special case is required due to how encoding/json treats
			// numbers
			case float64:
				var coercedFloat float64
				coercedFloat, err = coerceFloat64(item)
				coerced = int(coercedFloat)
			default:
				coerced, err = coerceInt(item)
			}
			if err != nil {
				return nil, &CoerceErr{val, "[]int", err}
			}
			container = append(container, coerced)
		}
		return container, nil
	default:
		return nil, &CoerceErr{From: val, To: "[]int"}
	}
}`
}

func writeCoercers(buff *bytes.Buffer) error {
	buff.WriteString(packageIntro)

	for _, typ := range types {
		fmt.Fprintf(buff, "func coerce%s(val interface{}) (%s, error) {\n\t", kindTitle(typ), typ.String())
		fmt.Fprintf(buff, writeCaster(typ)+"}\n\n")

		if typ == reflect.Int {
			fmt.Fprintf(buff, writeIntSliceCaster()+"\n\n")
		} else {
			fmt.Fprintf(buff, "func coerce%sSlice(val interface{}) ([]%s, error) {\n\t", kindTitle(typ), typ.String())
			fmt.Fprintf(buff, writeSliceCaster(typ)+"}\n\n")
		}
	}

	// gofmt
	res, err := format.Source(buff.Bytes())
	if err != nil {
		fmt.Println(buff.String())
		panic(err.Error())
	}

	// write result
	f, err := os.Create("coercers.go")
	if err != nil {
		panic(err.Error())
	}
	defer f.Close()
	f.Write(res)
	return nil
}

func writeCoercerTests(buff *bytes.Buffer) error {
	buff.WriteString(packageHdr)
	return nil
}

func main() {
	coercersBuff := new(bytes.Buffer)
	coercersTestBuff := new(bytes.Buffer)

	writeCoercers(coercersBuff)
	writeCoercerTests(coercersTestBuff)
}
